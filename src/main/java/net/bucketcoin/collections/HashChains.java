/*
 *    Copyright 2021 The Bucketcoin Authors
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package net.bucketcoin.collections;

import net.bucketcoin.crypto.Bucketcoin;
import net.bucketcoin.util.SerializationResources;
import org.apache.commons.io.FilenameUtils;
import org.jetbrains.annotations.NotNull;

import java.io.*;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Properties;

@SuppressWarnings("UnusedReturnValue")
public final class HashChains {

	private static File getPropertyFile(File file) {

		var p = FilenameUtils.getFullPathNoEndSeparator(file.getName());
		var i = FilenameUtils.getFullPathNoEndSeparator(p.replaceAll("^(.*)/.*?$","$1"))
				+ FilenameUtils.getBaseName(file.getName())
				+ "ChainProperties.properties";
		return new File(i);

	}

	/**
	 * Stores the HashChain in a file.
	 * @param hashChain The HashChain to store.
	 * @param file The file to store it in.
	 * @param checkValid Whether the chain should be validated. If it is not valid, <code>false</code>
	 *                   will be returned and the chain is not stored.
	 * @param <E> The HashChain type parameter.
	 * @return Whether the HashChain was stored.
	 * @throws IOException if an I/O error occurs.
	 */
	public static <E> boolean storeChain(@NotNull HashChain<E> hashChain, @NotNull File file, boolean checkValid) throws IOException {

		if(!hashChain.validate() && checkValid) return false;
		var ba = hashChain.toBlockArray();
		if(!file.exists()) //noinspection ResultOfMethodCallIgnored
			file.createNewFile();

		try(BufferedWriter bufferedWriter = new BufferedWriter(
				new FileWriter(file)
		)) {

			// String parentDir = Paths.get(file.getAbsoluteFile().getName()).getParent().toString();
			// File chainProperties = new File(parentDir + File.pathSeparator + FilenameUtils.getBaseName(file.getName()) + "ChainProperties.properties");
			var chainProperties = getPropertyFile(file);
			if(!chainProperties.exists()) {

				var k = chainProperties.createNewFile();
				if(!k) throw new IOException("Failed to create chain properties file at " + chainProperties.getAbsolutePath());

			}


			try(PrintWriter propWriter = new PrintWriter(
					new FileWriter(chainProperties)
			)) {

				var p = new Properties();
				p.put("ChainArrayCapacity", String.valueOf(hashChain.getArrayCapacity()));
				p.put("ArrayIncrement", String.valueOf(hashChain.increment()));
				p.put("ChainElementCount", String.valueOf(hashChain.size()));
				p.put("StructuralModifications", String.valueOf(hashChain.getStructuralModificationCount()));
				propWriter.println("""
						#
						# HASH CHAIN PROPERTIES
						# (net.bucketcoin.collections.HashChain)
						# Generated by the Bucketcoin Project
						# Bucketcoin Project VERSION\040""" + Bucketcoin.BucketcoinVersion + """
												
						#
						# CHARSET=""" + SerializationResources.getStandardCharset().toString());
				p.list(propWriter);

			}

			for(HashChainBlock h : ba) {

				if(h == null) continue;

				var b = h.asBytes();
				var s = new String(b, SerializationResources.getStandardCharset()) + '\n';
				bufferedWriter.write(s.toCharArray());

			}
		}

		return true;

	}

	public static <E> @NotNull HashChain<E> readChain(@NotNull File file) throws IOException {

		File propFile = getPropertyFile(file);

		if(!file.exists()) throw new FileNotFoundException("File " + file.getName() + " does not exist.");
		if(!propFile.exists()) throw new FileNotFoundException("File " + file.getName() + " does not exist.");

		var b = readAll(file);

		// read properties
		Properties p = new Properties();
		p.load(new FileReader(propFile));
		var cac = (int) p.get("ChainArrayCapacity");
		var ai = (int) p.get("ArrayIncrement");
		var cec = (int) p.get("ChainElementCount");
		var sm = (int) p.get("StructuralModifications");

		var hc = new HashChain<E>(ai, cac, false);
		for(byte[] bytes : b) {

			var hcb = HashChainBlock.fromBytes(bytes);
			hc.add(hcb, hc.data, hc.size());

		}

		hc.setModCount(sm);
		return hc;

	}

	/**
	 * Reads all the lines of the file provided and converts each line
	 * into a byte array, eventually leading to a two-dimensional byte
	 * array as the byte arrays from each line are combined.
	 * @param f The file to read.
	 * @return 	An array representation of the byte arrays from each line.
	 * @throws IOException If an I/O error occurs
	 *
	 */
	private static byte[][] readAll(@NotNull File f) throws IOException {

		ArrayList<byte[]> arrayList = new ArrayList<>();
		try(BufferedReader reader = new BufferedReader(
				new InputStreamReader(
						new FileInputStream(f),
						SerializationResources.getStandardCharset()
				)
		)) {

			var l = reader.lines();
			while(l.iterator().hasNext()) {

				String next =  l.iterator().next();
				arrayList.add(next.getBytes(SerializationResources.getStandardCharset()));

			}

		}

		return arrayList.toArray(byte[][]::new);

	}

}
